<?php
/**
 * News extension - shows recent changes on a wiki page.
 *
 * @file
 * @ingroup Extensions
 * @author Daniel Kinzler, brightbyte.de
 * @copyright Â© 2007 Daniel Kinzler
 * @licence GNU General Public Licence 2.0 or later
 */


if( !defined( 'MEDIAWIKI' ) ) {
	echo( "This file is an extension to the MediaWiki software and cannot be used standalone.\n" );
	die( 1 );
}

$wgExtensionCredits['other'][] = array(
	'path' => __FILE__,
	'name' => 'News',
	'author' => 'Daniel Kinzler, brightbyte.de',
	'url' => 'https://mediawiki.org/wiki/Extension:News',
	'descriptionmsg' => 'newsextension-desc',
);

$wgMessagesDirs['NewsExtension'] = __DIR__ . '/i18n';

$wgNewsFeedURLPattern = false; // pattern for feed-URLs; useful when using rewrites for canonical feed URLs
$wgNewsFeedUserPattern = false; // pattern to use for the author-field in feed items.

$wgAutoloadClasses['NewsRenderer'] = dirname( __FILE__ ) . '/NewsRenderer.php';
$wgAutoloadClasses['NewsFeedPage'] = dirname( __FILE__ ) . '/NewsRenderer.php';
$wgHooks['ArticleFromTitle'][] = 'wfNewsArticleFromTitle';
$wgHooks['SkinTemplateOutputPageBeforeExec'][] = 'wfNewsSkinTemplateOutputPageBeforeExec';
$wgHooks['ParserFirstCallInit'][] = 'wfNewsSetHooks';

//FIXME: find a way to override the feed URLs generated by OutputPage::getHeadLinks

function wfNewsSetHooks( $parser ) {
	$parser->setHook( 'news', 'wfNewsTag' );
	$parser->setHook( 'newsfeed', 'wfNewsFeedTag' );
	$parser->setHook( 'newsfeedlink', 'wfNewsFeedLinkTag' );

	return true;
}

function wfNewsTag( $templatetext, $argv, $parser ) {
    $context = RequestContext::getMain();

    $parser->getOutput()->updateCacheExpiry( 0 ); //TODO: use smart cache & purge...?
    $renderer = new NewsRenderer($context, $templatetext, $argv, $parser);

    return $renderer->renderNews();
}

function wfNewsFeedTag( $templatetext, $argv, $parser ) {
    $out = $parser->getOutput();
    $out->updateCacheExpiry( 0 ); //TODO: use smart cache & purge...?
    $out->setSyndicated( true );

    $silent = @$argv['silent'];
    if ( $silent === 'false' || $silent === 'no' || $silent === '0' )
        $silent = false;

    if ( $silent ) return "";

    $context = RequestContext::getMain();

    $renderer = new NewsRenderer($context, $templatetext, $argv, $parser);
    $html = $renderer->renderFeedPreview();
    return $html;
}

function wfNewsFeedLinkTag( $linktext, $argv, $parser ) {
    return NewsRenderer::renderFeedLink($linktext, $argv, $parser);
}

function wfNewsArticleFromTitle( $title, &$article, IContextSource $context ) {
    global $wgFeedClasses;
    $fname = 'extension/News: wfNewsArticleFromTitle';
    $request = $context->getRequest();

    $ns = $title->getNamespace();
    if ($ns < 0 || $ns == NS_SPECIAL || $ns == NS_MEDIAWIKI) return true;

    $format = $request->getVal( 'feed' );
    if (!$format) return true;

    $format = strtolower( trim($format) );

    $action = strtolower( trim( $request->getVal( 'action', 'view' ) ) );
    if ($action != 'view' && $action != 'purge') return true;

    if ( !isset($wgFeedClasses[$format] ) ) {
	wfDebug( "$fname: unknown feed format: $format \n" );
        wfHttpError(400, "Bad Request", "unknown feed format: " . $format); //TODO: better code & text
        return false;
    }

    if (!$title->exists()) {
	wfDebug( "$fname: feed page not found: " . $title->getPrefixedDBKey() . "\n" );
        wfHttpError(404, "Not Found", "feed page not found: " . $title->getPrefixedText()); //TODO: better text
        return false;
    }

    wfDebug( "$fname: handling feed request for " . $title->getPrefixedDBKey() . "\n" );

    $article = new NewsFeedPage( $title, $format );
    return false;
}

function wfNewsSkinTemplateOutputPageBeforeExec( $skin, $tpl ) {
    $feeds = $tpl->data['feeds'];
    if (!$feeds) return true;

    $title = $skin->getTitle(); //hack...

    foreach ($feeds as $format => $e) {
        $e['href'] = NewsRenderer::getFeedURL( $title, $format );
        $feeds[$format] = $e;
    }

    $tpl->set( 'feeds', $feeds );
    return true;
}

