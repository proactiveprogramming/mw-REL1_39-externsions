# Generated from stOTTR.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\39")
        buf.write("\u012d\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\3\2\3\2\7\2O\n\2\f\2\16\2R\13\2\3\2\3\2\3\3\3\3\3\3")
        buf.write("\3\3\5\3Z\n\3\3\3\3\3\3\4\3\4\3\4\5\4a\n\4\3\5\3\5\3\6")
        buf.write("\3\6\3\6\3\6\7\6i\n\6\f\6\16\6l\13\6\5\6n\n\6\3\6\3\6")
        buf.write("\3\7\7\7s\n\7\f\7\16\7v\13\7\3\7\5\7y\n\7\3\7\3\7\5\7")
        buf.write("}\n\7\3\b\3\b\3\b\3\t\3\t\3\t\7\t\u0085\n\t\f\t\16\t\u0088")
        buf.write("\13\t\3\n\3\n\3\n\3\13\3\13\3\13\3\13\3\f\3\f\3\f\3\f")
        buf.write("\3\r\3\r\3\r\3\r\7\r\u0099\n\r\f\r\16\r\u009c\13\r\5\r")
        buf.write("\u009e\n\r\3\r\3\r\3\16\3\16\5\16\u00a4\n\16\3\16\3\16")
        buf.write("\3\16\3\17\3\17\3\17\3\17\7\17\u00ad\n\17\f\17\16\17\u00b0")
        buf.write("\13\17\5\17\u00b2\n\17\3\17\3\17\3\20\5\20\u00b7\n\20")
        buf.write("\3\20\3\20\3\21\3\21\3\21\3\21\5\21\u00bf\n\21\3\22\3")
        buf.write("\22\3\22\3\22\3\23\3\23\3\23\3\23\3\24\3\24\3\24\3\24")
        buf.write("\3\25\3\25\3\26\3\26\3\26\5\26\u00d2\n\26\3\27\3\27\3")
        buf.write("\27\3\27\3\27\5\27\u00d9\n\27\3\30\3\30\3\31\3\31\3\31")
        buf.write("\3\31\7\31\u00e1\n\31\f\31\16\31\u00e4\13\31\5\31\u00e6")
        buf.write("\n\31\3\31\3\31\3\32\3\32\3\32\3\32\7\32\u00ee\n\32\f")
        buf.write("\32\16\32\u00f1\13\32\5\32\u00f3\n\32\3\32\3\32\3\33\3")
        buf.write("\33\3\33\3\33\5\33\u00fb\n\33\3\34\3\34\3\34\3\34\3\34")
        buf.write("\3\35\3\35\3\35\3\35\3\36\3\36\3\36\3\37\3\37\3\37\3\37")
        buf.write("\3 \3 \3 \5 \u0110\n \3!\3!\3\"\3\"\3\"\3\"\5\"\u0118")
        buf.write("\n\"\3#\3#\5#\u011c\n#\3$\3$\3%\3%\5%\u0122\n%\3&\3&\7")
        buf.write("&\u0126\n&\f&\16&\u0129\13&\3&\3&\3&\2\2\'\2\4\6\b\n\f")
        buf.write("\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@")
        buf.write("BDFHJ\2\4\3\2&(\3\2\"#\2\u0130\2P\3\2\2\2\4Y\3\2\2\2\6")
        buf.write("]\3\2\2\2\bb\3\2\2\2\nd\3\2\2\2\ft\3\2\2\2\16~\3\2\2\2")
        buf.write("\20\u0081\3\2\2\2\22\u0089\3\2\2\2\24\u008c\3\2\2\2\26")
        buf.write("\u0090\3\2\2\2\30\u0094\3\2\2\2\32\u00a3\3\2\2\2\34\u00a8")
        buf.write("\3\2\2\2\36\u00b6\3\2\2\2 \u00be\3\2\2\2\"\u00c0\3\2\2")
        buf.write("\2$\u00c4\3\2\2\2&\u00c8\3\2\2\2(\u00cc\3\2\2\2*\u00d1")
        buf.write("\3\2\2\2,\u00d8\3\2\2\2.\u00da\3\2\2\2\60\u00dc\3\2\2")
        buf.write("\2\62\u00e9\3\2\2\2\64\u00fa\3\2\2\2\66\u00fc\3\2\2\2")
        buf.write("8\u0101\3\2\2\2:\u0105\3\2\2\2<\u0108\3\2\2\2>\u010f\3")
        buf.write("\2\2\2@\u0111\3\2\2\2B\u0113\3\2\2\2D\u011b\3\2\2\2F\u011d")
        buf.write("\3\2\2\2H\u0121\3\2\2\2J\u0123\3\2\2\2LO\5\64\33\2MO\5")
        buf.write("\4\3\2NL\3\2\2\2NM\3\2\2\2OR\3\2\2\2PN\3\2\2\2PQ\3\2\2")
        buf.write("\2QS\3\2\2\2RP\3\2\2\2ST\7\2\2\3T\3\3\2\2\2UZ\5\6\4\2")
        buf.write("VZ\5\26\f\2WZ\5\24\13\2XZ\5\32\16\2YU\3\2\2\2YV\3\2\2")
        buf.write("\2YW\3\2\2\2YX\3\2\2\2Z[\3\2\2\2[\\\7\3\2\2\\\5\3\2\2")
        buf.write("\2]^\5\b\5\2^`\5\n\6\2_a\5\20\t\2`_\3\2\2\2`a\3\2\2\2")
        buf.write("a\7\3\2\2\2bc\5D#\2c\t\3\2\2\2dm\7\4\2\2ej\5\f\7\2fg\7")
        buf.write("\5\2\2gi\5\f\7\2hf\3\2\2\2il\3\2\2\2jh\3\2\2\2jk\3\2\2")
        buf.write("\2kn\3\2\2\2lj\3\2\2\2me\3\2\2\2mn\3\2\2\2no\3\2\2\2o")
        buf.write("p\7\6\2\2p\13\3\2\2\2qs\7\33\2\2rq\3\2\2\2sv\3\2\2\2t")
        buf.write("r\3\2\2\2tu\3\2\2\2ux\3\2\2\2vt\3\2\2\2wy\5 \21\2xw\3")
        buf.write("\2\2\2xy\3\2\2\2yz\3\2\2\2z|\7\36\2\2{}\5\16\b\2|{\3\2")
        buf.write("\2\2|}\3\2\2\2}\r\3\2\2\2~\177\7\7\2\2\177\u0080\5,\27")
        buf.write("\2\u0080\17\3\2\2\2\u0081\u0086\5\22\n\2\u0082\u0083\7")
        buf.write("\5\2\2\u0083\u0085\5\22\n\2\u0084\u0082\3\2\2\2\u0085")
        buf.write("\u0088\3\2\2\2\u0086\u0084\3\2\2\2\u0086\u0087\3\2\2\2")
        buf.write("\u0087\21\3\2\2\2\u0088\u0086\3\2\2\2\u0089\u008a\7\b")
        buf.write("\2\2\u008a\u008b\5\32\16\2\u008b\23\3\2\2\2\u008c\u008d")
        buf.write("\5\6\4\2\u008d\u008e\7\t\2\2\u008e\u008f\7\n\2\2\u008f")
        buf.write("\25\3\2\2\2\u0090\u0091\5\6\4\2\u0091\u0092\7\t\2\2\u0092")
        buf.write("\u0093\5\30\r\2\u0093\27\3\2\2\2\u0094\u009d\7\13\2\2")
        buf.write("\u0095\u009a\5\32\16\2\u0096\u0097\7\5\2\2\u0097\u0099")
        buf.write("\5\32\16\2\u0098\u0096\3\2\2\2\u0099\u009c\3\2\2\2\u009a")
        buf.write("\u0098\3\2\2\2\u009a\u009b\3\2\2\2\u009b\u009e\3\2\2\2")
        buf.write("\u009c\u009a\3\2\2\2\u009d\u0095\3\2\2\2\u009d\u009e\3")
        buf.write("\2\2\2\u009e\u009f\3\2\2\2\u009f\u00a0\7\f\2\2\u00a0\31")
        buf.write("\3\2\2\2\u00a1\u00a2\7\34\2\2\u00a2\u00a4\7\r\2\2\u00a3")
        buf.write("\u00a1\3\2\2\2\u00a3\u00a4\3\2\2\2\u00a4\u00a5\3\2\2\2")
        buf.write("\u00a5\u00a6\5\b\5\2\u00a6\u00a7\5\34\17\2\u00a7\33\3")
        buf.write("\2\2\2\u00a8\u00b1\7\16\2\2\u00a9\u00ae\5\36\20\2\u00aa")
        buf.write("\u00ab\7\5\2\2\u00ab\u00ad\5\36\20\2\u00ac\u00aa\3\2\2")
        buf.write("\2\u00ad\u00b0\3\2\2\2\u00ae\u00ac\3\2\2\2\u00ae\u00af")
        buf.write("\3\2\2\2\u00af\u00b2\3\2\2\2\u00b0\u00ae\3\2\2\2\u00b1")
        buf.write("\u00a9\3\2\2\2\u00b1\u00b2\3\2\2\2\u00b2\u00b3\3\2\2\2")
        buf.write("\u00b3\u00b4\7\17\2\2\u00b4\35\3\2\2\2\u00b5\u00b7\7\35")
        buf.write("\2\2\u00b6\u00b5\3\2\2\2\u00b6\u00b7\3\2\2\2\u00b7\u00b8")
        buf.write("\3\2\2\2\u00b8\u00b9\5*\26\2\u00b9\37\3\2\2\2\u00ba\u00bf")
        buf.write("\5(\25\2\u00bb\u00bf\5&\24\2\u00bc\u00bf\5\"\22\2\u00bd")
        buf.write("\u00bf\5$\23\2\u00be\u00ba\3\2\2\2\u00be\u00bb\3\2\2\2")
        buf.write("\u00be\u00bc\3\2\2\2\u00be\u00bd\3\2\2\2\u00bf!\3\2\2")
        buf.write("\2\u00c0\u00c1\7\20\2\2\u00c1\u00c2\5 \21\2\u00c2\u00c3")
        buf.write("\7\21\2\2\u00c3#\3\2\2\2\u00c4\u00c5\7\22\2\2\u00c5\u00c6")
        buf.write("\5 \21\2\u00c6\u00c7\7\21\2\2\u00c7%\3\2\2\2\u00c8\u00c9")
        buf.write("\7\23\2\2\u00c9\u00ca\5(\25\2\u00ca\u00cb\7\21\2\2\u00cb")
        buf.write("\'\3\2\2\2\u00cc\u00cd\5F$\2\u00cd)\3\2\2\2\u00ce\u00d2")
        buf.write("\7\36\2\2\u00cf\u00d2\5,\27\2\u00d0\u00d2\5\60\31\2\u00d1")
        buf.write("\u00ce\3\2\2\2\u00d1\u00cf\3\2\2\2\u00d1\u00d0\3\2\2\2")
        buf.write("\u00d2+\3\2\2\2\u00d3\u00d9\5D#\2\u00d4\u00d9\5H%\2\u00d5")
        buf.write("\u00d9\5> \2\u00d6\u00d9\5.\30\2\u00d7\u00d9\5\62\32\2")
        buf.write("\u00d8\u00d3\3\2\2\2\u00d8\u00d4\3\2\2\2\u00d8\u00d5\3")
        buf.write("\2\2\2\u00d8\u00d6\3\2\2\2\u00d8\u00d7\3\2\2\2\u00d9-")
        buf.write("\3\2\2\2\u00da\u00db\7\24\2\2\u00db/\3\2\2\2\u00dc\u00e5")
        buf.write("\7\16\2\2\u00dd\u00e2\5*\26\2\u00de\u00df\7\5\2\2\u00df")
        buf.write("\u00e1\5*\26\2\u00e0\u00de\3\2\2\2\u00e1\u00e4\3\2\2\2")
        buf.write("\u00e2\u00e0\3\2\2\2\u00e2\u00e3\3\2\2\2\u00e3\u00e6\3")
        buf.write("\2\2\2\u00e4\u00e2\3\2\2\2\u00e5\u00dd\3\2\2\2\u00e5\u00e6")
        buf.write("\3\2\2\2\u00e6\u00e7\3\2\2\2\u00e7\u00e8\7\17\2\2\u00e8")
        buf.write("\61\3\2\2\2\u00e9\u00f2\7\16\2\2\u00ea\u00ef\5,\27\2\u00eb")
        buf.write("\u00ec\7\5\2\2\u00ec\u00ee\5,\27\2\u00ed\u00eb\3\2\2\2")
        buf.write("\u00ee\u00f1\3\2\2\2\u00ef\u00ed\3\2\2\2\u00ef\u00f0\3")
        buf.write("\2\2\2\u00f0\u00f3\3\2\2\2\u00f1\u00ef\3\2\2\2\u00f2\u00ea")
        buf.write("\3\2\2\2\u00f2\u00f3\3\2\2\2\u00f3\u00f4\3\2\2\2\u00f4")
        buf.write("\u00f5\7\17\2\2\u00f5\63\3\2\2\2\u00f6\u00fb\5\66\34\2")
        buf.write("\u00f7\u00fb\58\35\2\u00f8\u00fb\5<\37\2\u00f9\u00fb\5")
        buf.write(":\36\2\u00fa\u00f6\3\2\2\2\u00fa\u00f7\3\2\2\2\u00fa\u00f8")
        buf.write("\3\2\2\2\u00fa\u00f9\3\2\2\2\u00fb\65\3\2\2\2\u00fc\u00fd")
        buf.write("\7\25\2\2\u00fd\u00fe\7\"\2\2\u00fe\u00ff\7!\2\2\u00ff")
        buf.write("\u0100\7\3\2\2\u0100\67\3\2\2\2\u0101\u0102\7\26\2\2\u0102")
        buf.write("\u0103\7!\2\2\u0103\u0104\7\3\2\2\u01049\3\2\2\2\u0105")
        buf.write("\u0106\7\n\2\2\u0106\u0107\7!\2\2\u0107;\3\2\2\2\u0108")
        buf.write("\u0109\7\27\2\2\u0109\u010a\7\"\2\2\u010a\u010b\7!\2\2")
        buf.write("\u010b=\3\2\2\2\u010c\u0110\5B\"\2\u010d\u0110\5@!\2\u010e")
        buf.write("\u0110\7\37\2\2\u010f\u010c\3\2\2\2\u010f\u010d\3\2\2")
        buf.write("\2\u010f\u010e\3\2\2\2\u0110?\3\2\2\2\u0111\u0112\t\2")
        buf.write("\2\2\u0112A\3\2\2\2\u0113\u0117\7 \2\2\u0114\u0118\7%")
        buf.write("\2\2\u0115\u0116\7\30\2\2\u0116\u0118\5D#\2\u0117\u0114")
        buf.write("\3\2\2\2\u0117\u0115\3\2\2\2\u0117\u0118\3\2\2\2\u0118")
        buf.write("C\3\2\2\2\u0119\u011c\7!\2\2\u011a\u011c\5F$\2\u011b\u0119")
        buf.write("\3\2\2\2\u011b\u011a\3\2\2\2\u011cE\3\2\2\2\u011d\u011e")
        buf.write("\t\3\2\2\u011eG\3\2\2\2\u011f\u0122\7$\2\2\u0120\u0122")
        buf.write("\5J&\2\u0121\u011f\3\2\2\2\u0121\u0120\3\2\2\2\u0122I")
        buf.write("\3\2\2\2\u0123\u0127\7\4\2\2\u0124\u0126\7\60\2\2\u0125")
        buf.write("\u0124\3\2\2\2\u0126\u0129\3\2\2\2\u0127\u0125\3\2\2\2")
        buf.write("\u0127\u0128\3\2\2\2\u0128\u012a\3\2\2\2\u0129\u0127\3")
        buf.write("\2\2\2\u012a\u012b\7\6\2\2\u012bK\3\2\2\2\37NPY`jmtx|")
        buf.write("\u0086\u009a\u009d\u00a3\u00ae\u00b1\u00b6\u00be\u00d1")
        buf.write("\u00d8\u00e2\u00e5\u00ef\u00f2\u00fa\u010f\u0117\u011b")
        buf.write("\u0121\u0127")
        return buf.getvalue()


class stOTTRParser ( Parser ):

    grammarFileName = "stOTTR.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'.'", "'['", "','", "']'", "'='", "'@@'", 
                     "'::'", "'BASE'", "'{'", "'}'", "'|'", "'('", "')'", 
                     "'List<'", "'>'", "'NEList<'", "'LUB<'", "'none'", 
                     "'@prefix'", "'@base'", "'PREFIX'", "'^^'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'++'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "Comment", 
                      "CommentBlock", "ParameterMode", "ListExpander", "ListExpand", 
                      "Variable", "BooleanLiteral", "String", "IRIREF", 
                      "PNAME_NS", "PNAME_LN", "BLANK_NODE_LABEL", "LANGTAG", 
                      "INTEGER", "DECIMAL", "DOUBLE", "EXPONENT", "STRING_LITERAL_QUOTE", 
                      "STRING_LITERAL_SINGLE_QUOTE", "STRING_LITERAL_LONG_SINGLE_QUOTE", 
                      "STRING_LITERAL_LONG_QUOTE", "UCHAR", "ECHAR", "WS", 
                      "PN_CHARS_BASE", "PN_CHARS_U", "PN_CHARS", "PN_PREFIX", 
                      "PN_LOCAL", "PLX", "PERCENT", "HEX", "PN_LOCAL_ESC" ]

    RULE_stOTTRDoc = 0
    RULE_statement = 1
    RULE_signature = 2
    RULE_templateName = 3
    RULE_parameterList = 4
    RULE_parameter = 5
    RULE_defaultValue = 6
    RULE_annotationList = 7
    RULE_annotation = 8
    RULE_baseTemplate = 9
    RULE_template = 10
    RULE_patternList = 11
    RULE_instance = 12
    RULE_argumentList = 13
    RULE_argument = 14
    RULE_otype = 15
    RULE_listType = 16
    RULE_neListType = 17
    RULE_lubType = 18
    RULE_basicType = 19
    RULE_term = 20
    RULE_constant = 21
    RULE_none = 22
    RULE_termList = 23
    RULE_constantList = 24
    RULE_directive = 25
    RULE_prefixID = 26
    RULE_base = 27
    RULE_sparqlBase = 28
    RULE_sparqlPrefix = 29
    RULE_literal = 30
    RULE_numericLiteral = 31
    RULE_rdfLiteral = 32
    RULE_iri = 33
    RULE_prefixedName = 34
    RULE_blankNode = 35
    RULE_anon = 36

    ruleNames =  [ "stOTTRDoc", "statement", "signature", "templateName", 
                   "parameterList", "parameter", "defaultValue", "annotationList", 
                   "annotation", "baseTemplate", "template", "patternList", 
                   "instance", "argumentList", "argument", "otype", "listType", 
                   "neListType", "lubType", "basicType", "term", "constant", 
                   "none", "termList", "constantList", "directive", "prefixID", 
                   "base", "sparqlBase", "sparqlPrefix", "literal", "numericLiteral", 
                   "rdfLiteral", "iri", "prefixedName", "blankNode", "anon" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    Comment=23
    CommentBlock=24
    ParameterMode=25
    ListExpander=26
    ListExpand=27
    Variable=28
    BooleanLiteral=29
    String=30
    IRIREF=31
    PNAME_NS=32
    PNAME_LN=33
    BLANK_NODE_LABEL=34
    LANGTAG=35
    INTEGER=36
    DECIMAL=37
    DOUBLE=38
    EXPONENT=39
    STRING_LITERAL_QUOTE=40
    STRING_LITERAL_SINGLE_QUOTE=41
    STRING_LITERAL_LONG_SINGLE_QUOTE=42
    STRING_LITERAL_LONG_QUOTE=43
    UCHAR=44
    ECHAR=45
    WS=46
    PN_CHARS_BASE=47
    PN_CHARS_U=48
    PN_CHARS=49
    PN_PREFIX=50
    PN_LOCAL=51
    PLX=52
    PERCENT=53
    HEX=54
    PN_LOCAL_ESC=55

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StOTTRDocContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(stOTTRParser.EOF, 0)

        def directive(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(stOTTRParser.DirectiveContext)
            else:
                return self.getTypedRuleContext(stOTTRParser.DirectiveContext,i)


        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(stOTTRParser.StatementContext)
            else:
                return self.getTypedRuleContext(stOTTRParser.StatementContext,i)


        def getRuleIndex(self):
            return stOTTRParser.RULE_stOTTRDoc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStOTTRDoc" ):
                listener.enterStOTTRDoc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStOTTRDoc" ):
                listener.exitStOTTRDoc(self)




    def stOTTRDoc(self):

        localctx = stOTTRParser.StOTTRDocContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_stOTTRDoc)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 78
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << stOTTRParser.T__7) | (1 << stOTTRParser.T__18) | (1 << stOTTRParser.T__19) | (1 << stOTTRParser.T__20) | (1 << stOTTRParser.ListExpander) | (1 << stOTTRParser.IRIREF) | (1 << stOTTRParser.PNAME_NS) | (1 << stOTTRParser.PNAME_LN))) != 0):
                self.state = 76
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [stOTTRParser.T__7, stOTTRParser.T__18, stOTTRParser.T__19, stOTTRParser.T__20]:
                    self.state = 74
                    self.directive()
                    pass
                elif token in [stOTTRParser.ListExpander, stOTTRParser.IRIREF, stOTTRParser.PNAME_NS, stOTTRParser.PNAME_LN]:
                    self.state = 75
                    self.statement()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 80
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 81
            self.match(stOTTRParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def signature(self):
            return self.getTypedRuleContext(stOTTRParser.SignatureContext,0)


        def template(self):
            return self.getTypedRuleContext(stOTTRParser.TemplateContext,0)


        def baseTemplate(self):
            return self.getTypedRuleContext(stOTTRParser.BaseTemplateContext,0)


        def instance(self):
            return self.getTypedRuleContext(stOTTRParser.InstanceContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = stOTTRParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 87
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.state = 83
                self.signature()
                pass

            elif la_ == 2:
                self.state = 84
                self.template()
                pass

            elif la_ == 3:
                self.state = 85
                self.baseTemplate()
                pass

            elif la_ == 4:
                self.state = 86
                self.instance()
                pass


            self.state = 89
            self.match(stOTTRParser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SignatureContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def templateName(self):
            return self.getTypedRuleContext(stOTTRParser.TemplateNameContext,0)


        def parameterList(self):
            return self.getTypedRuleContext(stOTTRParser.ParameterListContext,0)


        def annotationList(self):
            return self.getTypedRuleContext(stOTTRParser.AnnotationListContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_signature

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignature" ):
                listener.enterSignature(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignature" ):
                listener.exitSignature(self)




    def signature(self):

        localctx = stOTTRParser.SignatureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_signature)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 91
            self.templateName()
            self.state = 92
            self.parameterList()
            self.state = 94
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==stOTTRParser.T__5:
                self.state = 93
                self.annotationList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TemplateNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def iri(self):
            return self.getTypedRuleContext(stOTTRParser.IriContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_templateName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemplateName" ):
                listener.enterTemplateName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemplateName" ):
                listener.exitTemplateName(self)




    def templateName(self):

        localctx = stOTTRParser.TemplateNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_templateName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96
            self.iri()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(stOTTRParser.ParameterContext)
            else:
                return self.getTypedRuleContext(stOTTRParser.ParameterContext,i)


        def getRuleIndex(self):
            return stOTTRParser.RULE_parameterList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterList" ):
                listener.enterParameterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterList" ):
                listener.exitParameterList(self)




    def parameterList(self):

        localctx = stOTTRParser.ParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_parameterList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            self.match(stOTTRParser.T__1)
            self.state = 107
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << stOTTRParser.T__13) | (1 << stOTTRParser.T__15) | (1 << stOTTRParser.T__16) | (1 << stOTTRParser.ParameterMode) | (1 << stOTTRParser.Variable) | (1 << stOTTRParser.PNAME_NS) | (1 << stOTTRParser.PNAME_LN))) != 0):
                self.state = 99
                self.parameter()
                self.state = 104
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==stOTTRParser.T__2:
                    self.state = 100
                    self.match(stOTTRParser.T__2)
                    self.state = 101
                    self.parameter()
                    self.state = 106
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 109
            self.match(stOTTRParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Variable(self):
            return self.getToken(stOTTRParser.Variable, 0)

        def ParameterMode(self, i:int=None):
            if i is None:
                return self.getTokens(stOTTRParser.ParameterMode)
            else:
                return self.getToken(stOTTRParser.ParameterMode, i)

        def otype(self):
            return self.getTypedRuleContext(stOTTRParser.OtypeContext,0)


        def defaultValue(self):
            return self.getTypedRuleContext(stOTTRParser.DefaultValueContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)




    def parameter(self):

        localctx = stOTTRParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_parameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 114
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==stOTTRParser.ParameterMode:
                self.state = 111
                self.match(stOTTRParser.ParameterMode)
                self.state = 116
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 118
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << stOTTRParser.T__13) | (1 << stOTTRParser.T__15) | (1 << stOTTRParser.T__16) | (1 << stOTTRParser.PNAME_NS) | (1 << stOTTRParser.PNAME_LN))) != 0):
                self.state = 117
                self.otype()


            self.state = 120
            self.match(stOTTRParser.Variable)
            self.state = 122
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==stOTTRParser.T__4:
                self.state = 121
                self.defaultValue()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultValueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant(self):
            return self.getTypedRuleContext(stOTTRParser.ConstantContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_defaultValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefaultValue" ):
                listener.enterDefaultValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefaultValue" ):
                listener.exitDefaultValue(self)




    def defaultValue(self):

        localctx = stOTTRParser.DefaultValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_defaultValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 124
            self.match(stOTTRParser.T__4)
            self.state = 125
            self.constant()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnnotationListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(stOTTRParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(stOTTRParser.AnnotationContext,i)


        def getRuleIndex(self):
            return stOTTRParser.RULE_annotationList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotationList" ):
                listener.enterAnnotationList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotationList" ):
                listener.exitAnnotationList(self)




    def annotationList(self):

        localctx = stOTTRParser.AnnotationListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_annotationList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 127
            self.annotation()
            self.state = 132
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==stOTTRParser.T__2:
                self.state = 128
                self.match(stOTTRParser.T__2)
                self.state = 129
                self.annotation()
                self.state = 134
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnnotationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def instance(self):
            return self.getTypedRuleContext(stOTTRParser.InstanceContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_annotation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotation" ):
                listener.enterAnnotation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotation" ):
                listener.exitAnnotation(self)




    def annotation(self):

        localctx = stOTTRParser.AnnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_annotation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 135
            self.match(stOTTRParser.T__5)
            self.state = 136
            self.instance()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BaseTemplateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def signature(self):
            return self.getTypedRuleContext(stOTTRParser.SignatureContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_baseTemplate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBaseTemplate" ):
                listener.enterBaseTemplate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBaseTemplate" ):
                listener.exitBaseTemplate(self)




    def baseTemplate(self):

        localctx = stOTTRParser.BaseTemplateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_baseTemplate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 138
            self.signature()
            self.state = 139
            self.match(stOTTRParser.T__6)
            self.state = 140
            self.match(stOTTRParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TemplateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def signature(self):
            return self.getTypedRuleContext(stOTTRParser.SignatureContext,0)


        def patternList(self):
            return self.getTypedRuleContext(stOTTRParser.PatternListContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_template

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemplate" ):
                listener.enterTemplate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemplate" ):
                listener.exitTemplate(self)




    def template(self):

        localctx = stOTTRParser.TemplateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_template)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.signature()
            self.state = 143
            self.match(stOTTRParser.T__6)
            self.state = 144
            self.patternList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatternListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def instance(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(stOTTRParser.InstanceContext)
            else:
                return self.getTypedRuleContext(stOTTRParser.InstanceContext,i)


        def getRuleIndex(self):
            return stOTTRParser.RULE_patternList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatternList" ):
                listener.enterPatternList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatternList" ):
                listener.exitPatternList(self)




    def patternList(self):

        localctx = stOTTRParser.PatternListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_patternList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 146
            self.match(stOTTRParser.T__8)
            self.state = 155
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << stOTTRParser.ListExpander) | (1 << stOTTRParser.IRIREF) | (1 << stOTTRParser.PNAME_NS) | (1 << stOTTRParser.PNAME_LN))) != 0):
                self.state = 147
                self.instance()
                self.state = 152
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==stOTTRParser.T__2:
                    self.state = 148
                    self.match(stOTTRParser.T__2)
                    self.state = 149
                    self.instance()
                    self.state = 154
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 157
            self.match(stOTTRParser.T__9)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InstanceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def templateName(self):
            return self.getTypedRuleContext(stOTTRParser.TemplateNameContext,0)


        def argumentList(self):
            return self.getTypedRuleContext(stOTTRParser.ArgumentListContext,0)


        def ListExpander(self):
            return self.getToken(stOTTRParser.ListExpander, 0)

        def getRuleIndex(self):
            return stOTTRParser.RULE_instance

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstance" ):
                listener.enterInstance(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstance" ):
                listener.exitInstance(self)




    def instance(self):

        localctx = stOTTRParser.InstanceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_instance)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 161
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==stOTTRParser.ListExpander:
                self.state = 159
                self.match(stOTTRParser.ListExpander)
                self.state = 160
                self.match(stOTTRParser.T__10)


            self.state = 163
            self.templateName()
            self.state = 164
            self.argumentList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def argument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(stOTTRParser.ArgumentContext)
            else:
                return self.getTypedRuleContext(stOTTRParser.ArgumentContext,i)


        def getRuleIndex(self):
            return stOTTRParser.RULE_argumentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentList" ):
                listener.enterArgumentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentList" ):
                listener.exitArgumentList(self)




    def argumentList(self):

        localctx = stOTTRParser.ArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_argumentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 166
            self.match(stOTTRParser.T__11)
            self.state = 175
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << stOTTRParser.T__1) | (1 << stOTTRParser.T__11) | (1 << stOTTRParser.T__17) | (1 << stOTTRParser.ListExpand) | (1 << stOTTRParser.Variable) | (1 << stOTTRParser.BooleanLiteral) | (1 << stOTTRParser.String) | (1 << stOTTRParser.IRIREF) | (1 << stOTTRParser.PNAME_NS) | (1 << stOTTRParser.PNAME_LN) | (1 << stOTTRParser.BLANK_NODE_LABEL) | (1 << stOTTRParser.INTEGER) | (1 << stOTTRParser.DECIMAL) | (1 << stOTTRParser.DOUBLE))) != 0):
                self.state = 167
                self.argument()
                self.state = 172
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==stOTTRParser.T__2:
                    self.state = 168
                    self.match(stOTTRParser.T__2)
                    self.state = 169
                    self.argument()
                    self.state = 174
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 177
            self.match(stOTTRParser.T__12)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self):
            return self.getTypedRuleContext(stOTTRParser.TermContext,0)


        def ListExpand(self):
            return self.getToken(stOTTRParser.ListExpand, 0)

        def getRuleIndex(self):
            return stOTTRParser.RULE_argument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgument" ):
                listener.enterArgument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgument" ):
                listener.exitArgument(self)




    def argument(self):

        localctx = stOTTRParser.ArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_argument)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 180
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==stOTTRParser.ListExpand:
                self.state = 179
                self.match(stOTTRParser.ListExpand)


            self.state = 182
            self.term()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OtypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basicType(self):
            return self.getTypedRuleContext(stOTTRParser.BasicTypeContext,0)


        def lubType(self):
            return self.getTypedRuleContext(stOTTRParser.LubTypeContext,0)


        def listType(self):
            return self.getTypedRuleContext(stOTTRParser.ListTypeContext,0)


        def neListType(self):
            return self.getTypedRuleContext(stOTTRParser.NeListTypeContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_otype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOtype" ):
                listener.enterOtype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOtype" ):
                listener.exitOtype(self)




    def otype(self):

        localctx = stOTTRParser.OtypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_otype)
        try:
            self.state = 188
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [stOTTRParser.PNAME_NS, stOTTRParser.PNAME_LN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 184
                self.basicType()
                pass
            elif token in [stOTTRParser.T__16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 185
                self.lubType()
                pass
            elif token in [stOTTRParser.T__13]:
                self.enterOuterAlt(localctx, 3)
                self.state = 186
                self.listType()
                pass
            elif token in [stOTTRParser.T__15]:
                self.enterOuterAlt(localctx, 4)
                self.state = 187
                self.neListType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ListTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def otype(self):
            return self.getTypedRuleContext(stOTTRParser.OtypeContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_listType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterListType" ):
                listener.enterListType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitListType" ):
                listener.exitListType(self)




    def listType(self):

        localctx = stOTTRParser.ListTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_listType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 190
            self.match(stOTTRParser.T__13)
            self.state = 191
            self.otype()
            self.state = 192
            self.match(stOTTRParser.T__14)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NeListTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def otype(self):
            return self.getTypedRuleContext(stOTTRParser.OtypeContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_neListType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNeListType" ):
                listener.enterNeListType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNeListType" ):
                listener.exitNeListType(self)




    def neListType(self):

        localctx = stOTTRParser.NeListTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_neListType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 194
            self.match(stOTTRParser.T__15)
            self.state = 195
            self.otype()
            self.state = 196
            self.match(stOTTRParser.T__14)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LubTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basicType(self):
            return self.getTypedRuleContext(stOTTRParser.BasicTypeContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_lubType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLubType" ):
                listener.enterLubType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLubType" ):
                listener.exitLubType(self)




    def lubType(self):

        localctx = stOTTRParser.LubTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_lubType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 198
            self.match(stOTTRParser.T__16)
            self.state = 199
            self.basicType()
            self.state = 200
            self.match(stOTTRParser.T__14)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BasicTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def prefixedName(self):
            return self.getTypedRuleContext(stOTTRParser.PrefixedNameContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_basicType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBasicType" ):
                listener.enterBasicType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBasicType" ):
                listener.exitBasicType(self)




    def basicType(self):

        localctx = stOTTRParser.BasicTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_basicType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 202
            self.prefixedName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TermContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Variable(self):
            return self.getToken(stOTTRParser.Variable, 0)

        def constant(self):
            return self.getTypedRuleContext(stOTTRParser.ConstantContext,0)


        def termList(self):
            return self.getTypedRuleContext(stOTTRParser.TermListContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm" ):
                listener.enterTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm" ):
                listener.exitTerm(self)




    def term(self):

        localctx = stOTTRParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_term)
        try:
            self.state = 207
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 204
                self.match(stOTTRParser.Variable)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 205
                self.constant()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 206
                self.termList()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def iri(self):
            return self.getTypedRuleContext(stOTTRParser.IriContext,0)


        def blankNode(self):
            return self.getTypedRuleContext(stOTTRParser.BlankNodeContext,0)


        def literal(self):
            return self.getTypedRuleContext(stOTTRParser.LiteralContext,0)


        def none(self):
            return self.getTypedRuleContext(stOTTRParser.NoneContext,0)


        def constantList(self):
            return self.getTypedRuleContext(stOTTRParser.ConstantListContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant" ):
                listener.enterConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant" ):
                listener.exitConstant(self)




    def constant(self):

        localctx = stOTTRParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_constant)
        try:
            self.state = 214
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [stOTTRParser.IRIREF, stOTTRParser.PNAME_NS, stOTTRParser.PNAME_LN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 209
                self.iri()
                pass
            elif token in [stOTTRParser.T__1, stOTTRParser.BLANK_NODE_LABEL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 210
                self.blankNode()
                pass
            elif token in [stOTTRParser.BooleanLiteral, stOTTRParser.String, stOTTRParser.INTEGER, stOTTRParser.DECIMAL, stOTTRParser.DOUBLE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 211
                self.literal()
                pass
            elif token in [stOTTRParser.T__17]:
                self.enterOuterAlt(localctx, 4)
                self.state = 212
                self.none()
                pass
            elif token in [stOTTRParser.T__11]:
                self.enterOuterAlt(localctx, 5)
                self.state = 213
                self.constantList()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NoneContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return stOTTRParser.RULE_none

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNone" ):
                listener.enterNone(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNone" ):
                listener.exitNone(self)




    def none(self):

        localctx = stOTTRParser.NoneContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_none)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 216
            self.match(stOTTRParser.T__17)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TermListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(stOTTRParser.TermContext)
            else:
                return self.getTypedRuleContext(stOTTRParser.TermContext,i)


        def getRuleIndex(self):
            return stOTTRParser.RULE_termList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTermList" ):
                listener.enterTermList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTermList" ):
                listener.exitTermList(self)




    def termList(self):

        localctx = stOTTRParser.TermListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_termList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 218
            self.match(stOTTRParser.T__11)
            self.state = 227
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << stOTTRParser.T__1) | (1 << stOTTRParser.T__11) | (1 << stOTTRParser.T__17) | (1 << stOTTRParser.Variable) | (1 << stOTTRParser.BooleanLiteral) | (1 << stOTTRParser.String) | (1 << stOTTRParser.IRIREF) | (1 << stOTTRParser.PNAME_NS) | (1 << stOTTRParser.PNAME_LN) | (1 << stOTTRParser.BLANK_NODE_LABEL) | (1 << stOTTRParser.INTEGER) | (1 << stOTTRParser.DECIMAL) | (1 << stOTTRParser.DOUBLE))) != 0):
                self.state = 219
                self.term()
                self.state = 224
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==stOTTRParser.T__2:
                    self.state = 220
                    self.match(stOTTRParser.T__2)
                    self.state = 221
                    self.term()
                    self.state = 226
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 229
            self.match(stOTTRParser.T__12)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(stOTTRParser.ConstantContext)
            else:
                return self.getTypedRuleContext(stOTTRParser.ConstantContext,i)


        def getRuleIndex(self):
            return stOTTRParser.RULE_constantList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstantList" ):
                listener.enterConstantList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstantList" ):
                listener.exitConstantList(self)




    def constantList(self):

        localctx = stOTTRParser.ConstantListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_constantList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231
            self.match(stOTTRParser.T__11)
            self.state = 240
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << stOTTRParser.T__1) | (1 << stOTTRParser.T__11) | (1 << stOTTRParser.T__17) | (1 << stOTTRParser.BooleanLiteral) | (1 << stOTTRParser.String) | (1 << stOTTRParser.IRIREF) | (1 << stOTTRParser.PNAME_NS) | (1 << stOTTRParser.PNAME_LN) | (1 << stOTTRParser.BLANK_NODE_LABEL) | (1 << stOTTRParser.INTEGER) | (1 << stOTTRParser.DECIMAL) | (1 << stOTTRParser.DOUBLE))) != 0):
                self.state = 232
                self.constant()
                self.state = 237
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==stOTTRParser.T__2:
                    self.state = 233
                    self.match(stOTTRParser.T__2)
                    self.state = 234
                    self.constant()
                    self.state = 239
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 242
            self.match(stOTTRParser.T__12)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DirectiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def prefixID(self):
            return self.getTypedRuleContext(stOTTRParser.PrefixIDContext,0)


        def base(self):
            return self.getTypedRuleContext(stOTTRParser.BaseContext,0)


        def sparqlPrefix(self):
            return self.getTypedRuleContext(stOTTRParser.SparqlPrefixContext,0)


        def sparqlBase(self):
            return self.getTypedRuleContext(stOTTRParser.SparqlBaseContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirective" ):
                listener.enterDirective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirective" ):
                listener.exitDirective(self)




    def directive(self):

        localctx = stOTTRParser.DirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_directive)
        try:
            self.state = 248
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [stOTTRParser.T__18]:
                self.enterOuterAlt(localctx, 1)
                self.state = 244
                self.prefixID()
                pass
            elif token in [stOTTRParser.T__19]:
                self.enterOuterAlt(localctx, 2)
                self.state = 245
                self.base()
                pass
            elif token in [stOTTRParser.T__20]:
                self.enterOuterAlt(localctx, 3)
                self.state = 246
                self.sparqlPrefix()
                pass
            elif token in [stOTTRParser.T__7]:
                self.enterOuterAlt(localctx, 4)
                self.state = 247
                self.sparqlBase()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrefixIDContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PNAME_NS(self):
            return self.getToken(stOTTRParser.PNAME_NS, 0)

        def IRIREF(self):
            return self.getToken(stOTTRParser.IRIREF, 0)

        def getRuleIndex(self):
            return stOTTRParser.RULE_prefixID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrefixID" ):
                listener.enterPrefixID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrefixID" ):
                listener.exitPrefixID(self)




    def prefixID(self):

        localctx = stOTTRParser.PrefixIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_prefixID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 250
            self.match(stOTTRParser.T__18)
            self.state = 251
            self.match(stOTTRParser.PNAME_NS)
            self.state = 252
            self.match(stOTTRParser.IRIREF)
            self.state = 253
            self.match(stOTTRParser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BaseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IRIREF(self):
            return self.getToken(stOTTRParser.IRIREF, 0)

        def getRuleIndex(self):
            return stOTTRParser.RULE_base

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBase" ):
                listener.enterBase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBase" ):
                listener.exitBase(self)




    def base(self):

        localctx = stOTTRParser.BaseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_base)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 255
            self.match(stOTTRParser.T__19)
            self.state = 256
            self.match(stOTTRParser.IRIREF)
            self.state = 257
            self.match(stOTTRParser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SparqlBaseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IRIREF(self):
            return self.getToken(stOTTRParser.IRIREF, 0)

        def getRuleIndex(self):
            return stOTTRParser.RULE_sparqlBase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSparqlBase" ):
                listener.enterSparqlBase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSparqlBase" ):
                listener.exitSparqlBase(self)




    def sparqlBase(self):

        localctx = stOTTRParser.SparqlBaseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_sparqlBase)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 259
            self.match(stOTTRParser.T__7)
            self.state = 260
            self.match(stOTTRParser.IRIREF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SparqlPrefixContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PNAME_NS(self):
            return self.getToken(stOTTRParser.PNAME_NS, 0)

        def IRIREF(self):
            return self.getToken(stOTTRParser.IRIREF, 0)

        def getRuleIndex(self):
            return stOTTRParser.RULE_sparqlPrefix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSparqlPrefix" ):
                listener.enterSparqlPrefix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSparqlPrefix" ):
                listener.exitSparqlPrefix(self)




    def sparqlPrefix(self):

        localctx = stOTTRParser.SparqlPrefixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_sparqlPrefix)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 262
            self.match(stOTTRParser.T__20)
            self.state = 263
            self.match(stOTTRParser.PNAME_NS)
            self.state = 264
            self.match(stOTTRParser.IRIREF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rdfLiteral(self):
            return self.getTypedRuleContext(stOTTRParser.RdfLiteralContext,0)


        def numericLiteral(self):
            return self.getTypedRuleContext(stOTTRParser.NumericLiteralContext,0)


        def BooleanLiteral(self):
            return self.getToken(stOTTRParser.BooleanLiteral, 0)

        def getRuleIndex(self):
            return stOTTRParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)




    def literal(self):

        localctx = stOTTRParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_literal)
        try:
            self.state = 269
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [stOTTRParser.String]:
                self.enterOuterAlt(localctx, 1)
                self.state = 266
                self.rdfLiteral()
                pass
            elif token in [stOTTRParser.INTEGER, stOTTRParser.DECIMAL, stOTTRParser.DOUBLE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 267
                self.numericLiteral()
                pass
            elif token in [stOTTRParser.BooleanLiteral]:
                self.enterOuterAlt(localctx, 3)
                self.state = 268
                self.match(stOTTRParser.BooleanLiteral)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(stOTTRParser.INTEGER, 0)

        def DECIMAL(self):
            return self.getToken(stOTTRParser.DECIMAL, 0)

        def DOUBLE(self):
            return self.getToken(stOTTRParser.DOUBLE, 0)

        def getRuleIndex(self):
            return stOTTRParser.RULE_numericLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericLiteral" ):
                listener.enterNumericLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericLiteral" ):
                listener.exitNumericLiteral(self)




    def numericLiteral(self):

        localctx = stOTTRParser.NumericLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_numericLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 271
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << stOTTRParser.INTEGER) | (1 << stOTTRParser.DECIMAL) | (1 << stOTTRParser.DOUBLE))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RdfLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def String(self):
            return self.getToken(stOTTRParser.String, 0)

        def LANGTAG(self):
            return self.getToken(stOTTRParser.LANGTAG, 0)

        def iri(self):
            return self.getTypedRuleContext(stOTTRParser.IriContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_rdfLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRdfLiteral" ):
                listener.enterRdfLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRdfLiteral" ):
                listener.exitRdfLiteral(self)




    def rdfLiteral(self):

        localctx = stOTTRParser.RdfLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_rdfLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 273
            self.match(stOTTRParser.String)
            self.state = 277
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [stOTTRParser.LANGTAG]:
                self.state = 274
                self.match(stOTTRParser.LANGTAG)
                pass
            elif token in [stOTTRParser.T__21]:
                self.state = 275
                self.match(stOTTRParser.T__21)
                self.state = 276
                self.iri()
                pass
            elif token in [stOTTRParser.T__2, stOTTRParser.T__3, stOTTRParser.T__12]:
                pass
            else:
                pass
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IriContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IRIREF(self):
            return self.getToken(stOTTRParser.IRIREF, 0)

        def prefixedName(self):
            return self.getTypedRuleContext(stOTTRParser.PrefixedNameContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_iri

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIri" ):
                listener.enterIri(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIri" ):
                listener.exitIri(self)




    def iri(self):

        localctx = stOTTRParser.IriContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_iri)
        try:
            self.state = 281
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [stOTTRParser.IRIREF]:
                self.enterOuterAlt(localctx, 1)
                self.state = 279
                self.match(stOTTRParser.IRIREF)
                pass
            elif token in [stOTTRParser.PNAME_NS, stOTTRParser.PNAME_LN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 280
                self.prefixedName()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrefixedNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PNAME_LN(self):
            return self.getToken(stOTTRParser.PNAME_LN, 0)

        def PNAME_NS(self):
            return self.getToken(stOTTRParser.PNAME_NS, 0)

        def getRuleIndex(self):
            return stOTTRParser.RULE_prefixedName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrefixedName" ):
                listener.enterPrefixedName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrefixedName" ):
                listener.exitPrefixedName(self)




    def prefixedName(self):

        localctx = stOTTRParser.PrefixedNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_prefixedName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 283
            _la = self._input.LA(1)
            if not(_la==stOTTRParser.PNAME_NS or _la==stOTTRParser.PNAME_LN):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlankNodeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BLANK_NODE_LABEL(self):
            return self.getToken(stOTTRParser.BLANK_NODE_LABEL, 0)

        def anon(self):
            return self.getTypedRuleContext(stOTTRParser.AnonContext,0)


        def getRuleIndex(self):
            return stOTTRParser.RULE_blankNode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlankNode" ):
                listener.enterBlankNode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlankNode" ):
                listener.exitBlankNode(self)




    def blankNode(self):

        localctx = stOTTRParser.BlankNodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_blankNode)
        try:
            self.state = 287
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [stOTTRParser.BLANK_NODE_LABEL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 285
                self.match(stOTTRParser.BLANK_NODE_LABEL)
                pass
            elif token in [stOTTRParser.T__1]:
                self.enterOuterAlt(localctx, 2)
                self.state = 286
                self.anon()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnonContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(stOTTRParser.WS)
            else:
                return self.getToken(stOTTRParser.WS, i)

        def getRuleIndex(self):
            return stOTTRParser.RULE_anon

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnon" ):
                listener.enterAnon(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnon" ):
                listener.exitAnon(self)




    def anon(self):

        localctx = stOTTRParser.AnonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_anon)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 289
            self.match(stOTTRParser.T__1)
            self.state = 293
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==stOTTRParser.WS:
                self.state = 290
                self.match(stOTTRParser.WS)
                self.state = 295
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 296
            self.match(stOTTRParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





